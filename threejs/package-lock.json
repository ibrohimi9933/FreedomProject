{
//  "lockfileVersion": 1
}
function mipmap( size, color ) {

            var imageCanvas = document.createElement( "canvas" ),
                context = imageCanvas.getContext( "2d" );

            imageCanvas.width = imageCanvas.height = size;

            context.fillStyle = "#444";
            context.fillRect( 0, 0, size, size );

            context.fillStyle = color;
            context.fillRect( 0, 0, size / 2, size / 2 );
            context.fillRect( size / 2, size / 2, size / 2, size / 2 );
            return imageCanvas;

        }

        var canvas = mipmap( 128, '#f00' );
        var textureCanvas1 = new THREE.CanvasTexture( canvas );
        textureCanvas1.mipmaps[ 0 ] = canvas;
        textureCanvas1.mipmaps[ 1 ] = mipmap( 64, '#0f0' );
        textureCanvas1.mipmaps[ 2 ] = mipmap( 32, '#00f' );
        textureCanvas1.mipmaps[ 3 ] = mipmap( 16, '#400' );
        textureCanvas1.mipmaps[ 4 ] = mipmap( 8,  '#040' );
        textureCanvas1.mipmaps[ 5 ] = mipmap( 4,  '#004' );
        textureCanvas1.mipmaps[ 6 ] = mipmap( 2,  '#044' );
        textureCanvas1.mipmaps[ 7 ] = mipmap( 1,  '#404' );
        textureCanvas1.repeat.set( 1000, 1000 );
        textureCanvas1.wrapS = THREE.RepeatWrapping;
        textureCanvas1.wrapT = THREE.RepeatWrapping;

        var textureCanvas2 = textureCanvas1.clone();
        textureCanvas2.maxFilter = THREE.NearestFilter;
        textureCanvas2.minFilter = THREE.NearestMipMapFilter;

        materialCanvas1 = new THREE.MeshBasicMaterial( { map: textureCanvas1 } );
        materialCanvas2 = new THREE.MeshBasicMaterial( { color: 0xffccaa, map: textureCanvas2 } );

        //var meshCanvas1 = new THREE.Mesh( geometry, materialCanvas1 );
        //meshCanvas1.rotation.x = -Math.PI / 4;
        //mathCanvas1.rotation.y = -Math.PI / 2;
        //meshCanvas1.scale.set(750, 800, 1000);

        var meshCanvas2 = new THREE.Mesh ( geometry, materialCanvas2 );
        mathCanvas2.rotation.y = -Math.PI / 2;
        meshCanvas2.rotation.x = -Math.PI / 4;
        meshCanvas2.scale.set(750, 800, 1000 );
        var createAddCube = new THREE.Mesh (
            new THREE.BoxGeometry (1, 1, 1)
            new THREE.MeshBasicMaterial()
        //box.position.set(0, 0, -2);
        var testDepth = THREE.Mesh;
        textureCanvas1.mipmaps(THREE.NearestFilter);
        var testWrap = THREE depthTest (1000);
        box.position.set(0, 0, -2);
        
        var textureCanvas3 = textureCanvas2.clone();
        textureCanvas3.maxFilter = THREE.NearestFilter;
        textureCanvas3.minFilter = THREE.NearestMipMapFilter;
        var testDepth = THREE.Mesh;
        contextFill( 60, 75, );
        
        var textureCanvas3;
        var fovTexture = textureCanvas3.clone();
        textureCanvas3.maxFilter = THREE.NearestFilter;
        textureCanvas3.minFilter = THREE.NearestMipMapFilter;
        contextFill( 75, 90);
        var fovDepth = deapthTest (1000);
        testWrap = new THREE.Mesh (
            THREE.BoxGeometry (0, 0, 1, 1)
            THREE.MeshBasicMaterial()
        console.log(depthTest, fovTexture);
        
        var THREE.bubbles
        textureCanvas = THREE.MaterialList(40);
        contextFill(r, g, b);
        meshCanvas1.rotation.x = -Math.PI / 4;
        var meshCanvas3.rotation.y = -Math.PI /8;
        contextFill(75, 100);